# This is new file

> 我理解的linux驱动：封装对底层硬件的操作，向上层应用提供操作接口

**开发环境的搭建**：内核源码树、nfs挂载的roofs、开发配置好相应的`bootcmd`和`bootargs`

**驱动开发的步骤**：1.驱动源码代码的编写、`Makefile`文件编写、编译得到；2.insmod装载模块、测试，rmmod卸载模块。

**bootcmd和bootargs**
```
1.设置bootcmd使开发板能够通过tftp下载自己建立的内核源码树编译得到的zImage
  set bootcmd 'tftp 0x30008000 zImage;bootm 0x30008000'
(注：bootcmd=movi read kernel 30008000; movi read rootfs 30B00000 300000; bootm 30008000 30B00000 这样的bootcmd是从inand启动内核的时候用的)

2.设置bootargs使开发板从nfs去挂载rootfs（内核配置记得打开使能nfs形式的rootfs）
setenv bootargs root=/dev/nfs nfsroot=192.168.1.141:/root/x210_porting/rootfs/rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off  init=/linuxrc console=ttySAC2,115200 
```
**编译驱动源码的Makefile文件**
```c
#ubuntu的内核源码树，如果要编译在ubuntu中安装的模块就打开这2个
#KERN_VER = $(shell uname -r)
#KERN_DIR = /lib/modules/$(KERN_VER)/build	
		
# 开发板的linux内核的源码树目录,根据自己在源码树存放的目录修改
KERN_DIR = /root/driver/kernel
obj-m	+= module_test.o     //-m 表示我们要将module_test.c编译成一个模块
                           //-y表示我们要将module_test.c编译链接进zImage
all:
	make -C $(KERN_DIR) M=`pwd` modules 
                           //-C 表示进入到某一个目录下去编译
                           //`pwd`：表示把两个`号中间的内容当成命令执行
                           //M=`pwd`则表示把pwd打印的内容保存起来，目的是为了编译好了之后能够返回原来的目录
                           //modules就是真正用来编译模块的命令，在内核的其他地方定义过了
cp:									
	cp *.ko /root/porting_x210/rootfs/rootfs/driver_test

.PHONY: clean	//把clean当成一个伪目标
clean:
	make -C $(KERN_DIR) M=`pwd` modules clean
```
总结：模块的makefile非常简单，本身并不能完成模块的编译，而是通过make -C进入到内核源码树下借用内核源码的体系来完成模块的编译链接的。

[TOC]
##字符设备基础
###从一个最简单的模块源码说起
```c
#include <linux/module.h>		// module_init  module_exit
#include <linux/init.h>			// __init   __exit
// 模块安装函数
static int __init chrdev_init(void)
{	
	printk(KERN_INFO "chrdev_init helloworld init\n");
	return 0;
}
// 模块卸载函数
static void __exit chrdev_exit(void)
{
	printk(KERN_INFO "chrdev_exit helloworld exit\n");
}
module_init(chrdev_init);
module_exit(chrdev_exit);

// MODULE_xxx这种宏作用是用来添加模块描述信息
MODULE_LICENSE("GPL");				// 描述模块的许可证
```
(1)使用printk打印调试信息，printk可以设置打印级别。常见的KERN_DBUG-8\KERN_INFO-7,当前系统也有一个打印信息的级别0-7（比如当前系统打印信息的级别为4，则printk打印小于级别4）。

    查看当前系统打印信息的级别：cat /proc/sys/kernel/printk;修改：echo 8 > /proc/sys/kernel/printk
(2)驱动源代码中包含的头文件和原来应用编程程序中包含的头文件不是一回事。应用编程中包含的头文件是应用层的头文件，是应用程序的编译器带来的（譬如gcc的头文件路径在/usr/include下，这些东西是和操作系统无关的）。驱动源码属于内核源码的一部分，驱动源码中的头文件其实就是内核源代码目录下的include目录下的头文件。

(3)函数修饰符`__init`（前面加下划线的表示这是给内核使用的函数），本质上是个宏定义，在内核源代码中就有`#define __init xxxx`。这个`__init`的作用就是将被他修饰的函数放入`.init.text`段中去（本来默认情况下函数是被放入`.text`段中）。

    #define __init	__section(.init.text) __cold notrace
                          ├──#define __section(S) __attribute__ ((__section__(#S)))              
整个内核中的所有的这类函数都会被链接器链接放入.init.text段中，所以所有的内核模块的`__init`修饰的函数其实是被统一放在一起的。
内核启动时统一会加载`.init.text`段中的这些模块安装函数，加载完后就会把这个段给释放掉以节省内存。`__exit`同理。















最简单的理解1

![图片](https://raw.githubusercontent.com/TongxinV/Mynote-Embedded/master/5.Linux%20driver%20development/assets/%E5%9B%BE%E7%89%871.png)



















      


