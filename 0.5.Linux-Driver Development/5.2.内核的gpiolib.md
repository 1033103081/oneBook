
随笔--linux内核的gpiolib学习
============================

> gpiolib引入：(1)一个事实：很多硬件都要用到GPIO，**GPIO会复用**；(2)如果同一个GPIO被2个驱动同时控制了，就会出现bug；(3)**内核提供gpiolib来统一管理系统中所有GPIO**；(4)gpiolib本身属于驱动框架的一部分


**gpiolib学习重点**：

* gpiolib的建立过程：和虚拟地址的建立类似，内核在启动的过程中去调用gpiolib建立函数建立gpiolib
* gpiolib的使用方法：申请、使用、释放
* gpiolib的架构：涉及哪些目录的哪些文件里面的哪些函数哪些数据结构哪些变量，谁调用谁，为什么要分开为什么不写在一个文件，等你能理解这些的时候你就有了架构意识。

[TOC]

###开机调用gpiolib的建立函数
> gpiolib的建立函数：`s5pv210_gpiolib_init`

![p.5-3-01](https://raw.githubusercontent.com/TongxinV/oneBook/master/0.5.Linux-Driver%20Development/assets/%E5%9B%BE%E7%89%87.5-3-01.png)


###gpiolib的建立
> 填充一个个`s3c_gpio_chip`这个结构体定义的变量（GPIO端口的抽象），最后把一个个端口的抽象的地址挂接到内核维护的一个`gpio_desc结构体指针数组`

![p.5-3-02](https://raw.githubusercontent.com/TongxinV/oneBook/master/0.5.Linux-Driver%20Development/assets/%E5%9B%BE%E7%89%87.5-3-02.png)

**struct s3c_gpio_chip**：<br>
(1)这个结构体是一个**GPIO端口的抽象**,这个结构体的一个变量就可以完全的描述一个端口。<br>
(2)**端口**和**IO口**是两个概念。S5PV210有很多个IO口（160个左右），这些IO口被分成N个端口(port)，每个端口包含了M个IO口。(M个IO口又被映射到一个一个的寄存器).(有时候一个端口就只有一个寄存器代表有时候也有多个)。譬如GPA0是一个端口组，里面包含了8个IO口，我们一般记作：GPA0_0（或GPA0.0）、GPA0_1...<br>
这是芯片设计决定的<br>
(3)内核中为每个GPIO分配了一个编号，编号是一个数字（譬如一共有160个IO时编号就可以从1到160连续分布），编号可以让程序很方便的去识别每一个GPIO。

附：
[arch/arm/plat-samsung/include/plat/gpio-core.h：struct s3c_gpio_chip](https://github.com/TongxinV/kernel2.6.35/blob/master/arch/arm/plat-samsung/include/plat/gpio-core.h)<br>
[include/asm-generic/gpio.h：struct gpio_chip](https://github.com/TongxinV/kernel2.6.35/blob/master/include/asm-generic/gpio.h)<br>
[arch/arm/plat-samsung/include/plat/gpio-cfg.h：struct s3c_gpio_cfg](https://github.com/TongxinV/kernel2.6.35/blob/master/arch/arm/plat-samsung/include/plat/gpio-cfg.h)

**s5pv210_gpio_4bit**：<br>
(1)这个东西是一个结构体数组，数组中包含了很多个`struct s3c_gpio_chip`类型的变量。一个`struct s3c_gpio_chip`类型的变量就代表了一个端口<br>
(2)S5PV210_GPA0宏：设置当前端口的基础编号（读者自行追踪，慢慢体会），区别`s3c_gpio_chip`里的`base`<br>
附：[S5PV210_GPA0宏](https://github.com/TongxinV/oneBook/blob/master/0.5.Linux-Driver%20Development/assets/%E5%9B%BE%E7%89%87.5-3-03.png)

**函数samsung_gpiolib_add_4bit_chips**：<br>
具体进行gpiolib的注册的。这个函数接收的参数是我们当前文件中定义好的结构体数组`s5pv210_gpio_4bit`（2个参数分别是数组名和数组元素个数），这个数组中其实就包含了当前系统中所有的IO端口的信息（这些信息包含：端口的名字、端口中所有GPIO的编号、端口操作寄存器组的虚拟地址基地址、端口中IO口的数量、端口上下拉等模式的配置函数、端口中的IO口换算其对应的中断号的函数等，有一些当前还没被赋值，接下来会被填充好）

    samsung_gpiolib_add_4bit_chips
        ├── samsung_gpiolib_add_4bit
        └── s3c_gpiolib_add
                └── gpiochip_add
samsung_gpiolib_add_4bit：

s3c_gpiolib_add























